% =========================================================================
% EMS VCS3 VCF - EXACT IMPLEMENTATION (Zambon & Fontana, 2011)
% Using self-generated pink noise via Paul Kellet's algorithm.
% =========================================================================

clc; clear; close all;

%% ------------------ 1) Define Constants and Desired fc ------------------
C       = 0.1e-6;         % 0.1 microfarad
eta     = 1.836;          
VT      = 26e-3;          % 26 mV
gamma   = eta * VT;       % ~48 mV

fc      = 1000;           % desired cutoff frequency (Hz)
K       = 1;              % feedback gain

% Choose I0 so that the small-signal pole is near fc.
I0 = 2 * C * (2*pi*fc);   % simple approximation

%% ------------------ 2) Discretization Parameters ------------------
Fs         = 44100;                 % base sampling rate (Hz)
T          = 1 / Fs;               
oversample = 8;                    
Fs_os      = Fs * oversample;      
T_os       = 1 / Fs_os;            

%% ------------------ 3) Generate and Upsample Pink Noise ------------------
% Generate pink noise using Paul Kellet's algorithm.
duration = 10;                % seconds
N = Fs * duration;
white = randn(N,1);
% Paul Kellet's filter coefficients:
b = [0.049922035, -0.095993537, 0.050612699, -0.004408786];
a = [1, -2.494956002, 2.017265875, -0.522189400];
pinkNoise = filter(b, a, white);
pinkNoise = pinkNoise / max(abs(pinkNoise));  % normalize to ±1

% Scale input to tens-of-mV range (e.g., ±50 mV)
inputScale = 0.05;
pinkNoise = pinkNoise * inputScale;

% Upsample to Fs_os:
pinkNoise_os = resample(pinkNoise, oversample, 1, 100);
y_os = zeros(size(pinkNoise_os));

%% ------------------ 4) Initialize State Variables ------------------
% State vector x = [x1; x2; x3; x4; x5] as in Eq. (2)
x   = zeros(5,1);
vC4 = 0;  % Capacitor voltage (vOUT = (K + 1/2)*vC4)

% Initialize auxiliary variable F0 per Eq. (7): F0(0) = (T_os/2)*f(ṽ0,x0)
vIN0 = pinkNoise_os(1);
f0   = vcs3_filter_dynamics(x, vIN0, I0, C, VT, gamma, K);
F0   = (T_os/2) * f0;

% Initialize previous derivative for trapezoidal integration of vC4.
f_prev = -(I0/(2*C)) * (x(5) + x(3));

%% ------------------ 5) Filter Processing (Oversampled) ------------------
N_os = length(pinkNoise_os);
for n = 1:N_os-1
    vIN_next = pinkNoise_os(n+1);
    
    % Newton–Raphson update to compute new state (and update F0)
    [x, F0] = vcs3_step(x, F0, vIN_next, I0, C, VT, gamma, K, T_os);
    
    % Trapezoidal integration of vC4:
    f_now = -(I0/(2*C)) * (x(5) + x(3));
    vC4   = vC4 + (T_os/2) * (f_prev + f_now);
    f_prev = f_now;
    
    % Filter output:
    y_os(n) = (K + 0.5) * vC4;
end

%% ------------------ 6) Downsample & Save Output ------------------
y = resample(y_os, 1, oversample, 100);
audiowrite('Filtered_PinkNoise.wav', y, Fs);

%% ==================== Local Functions ================================
%% -------------------------------------------------------------------------
function dx = vcs3_filter_dynamics(x, vIN, I0, C, VT, gamma, K)
    % Computes the derivative vector (Eq. (4)) using the addition formula.
    v_tilde = tanh(vIN/(2*VT));
    x1 = x(1); x2 = x(2); x3 = x(3); x4 = x(4); x5 = x(5);
    
    c1 = I0/(4*C*gamma);
    c2 = I0/(4*C*gamma);
    c3 = I0/(4*C*gamma);
    c4 = I0*(K+0.5)/(4*C*VT);
    c5 = I0/(12*C*gamma);
    
    % Clamp denominator to avoid division by zero:
    denom = 1 - v_tilde*x4;
    if abs(denom) < 1e-9, denom = sign(denom)*1e-9; end
    
    dx = zeros(5,1);
    dx(1) = c1 * ((x2 - v_tilde - x4) / denom) * (1 - x1^2);
    dx(2) = c2 * (x3 - 2*x2 + x1) * (1 - x2^2);
    dx(3) = c3 * (-x5 - 2*x3 - x2) * (1 - x3^2);
    dx(4) = c4 * (-x5 - x3) * (1 - x4^2);
    dx(5) = c5 * (-x5 - x3) * (1 - x5^2);
end

%% -------------------------------------------------------------------------
function [x_next, F0_next] = vcs3_step(x, F0, vIN_next, I0, C, VT, gamma, K, T)
    % Newton–Raphson solver for the implicit equation:
    % F(ξ) = F0 + (T/2)*f(v_tilde,ξ) - ξ = 0, where v_tilde = tanh(vIN_next/(2*VT)).
    x_next   = x;
    max_iter = 10;
    tol      = 1e-8;
    
    v_tilde = tanh(vIN_next/(2*VT));
    for iter = 1:max_iter
        f_val = vcs3_filter_dynamics(x_next, vIN_next, I0, C, VT, gamma, K);
        F = F0 + (T/2)*f_val - x_next;
        
        J_f = compute_jacobian(x_next, v_tilde, I0, C, VT, gamma, K);
        J_F = (T/2)*J_f - eye(5);
        
        if rcond(J_F) < 1e-12
            delta = pinv(J_F)*(-F);
        else
            delta = J_F\(-F);
        end
        
        % (Optionally, you can add damping here if needed.)
        x_next = x_next + delta;
        if norm(delta, inf) < tol
            break;
        end
    end
    F0_next = 2*x_next - F0;  % Update F0 per Eq. (8)
end

%% -------------------------------------------------------------------------
function J_f = compute_jacobian(x, v_tilde, I0, C, VT, gamma, K)
    % Computes the Jacobian matrix (Eq. (11)) of the dynamics function.
    x1 = x(1); x2 = x(2); x3 = x(3); x4 = x(4); x5 = x(5);
    
    c1 = I0/(4*C*gamma);
    c2 = I0/(4*C*gamma);
    c3 = I0/(4*C*gamma);
    c4 = I0*(K+0.5)/(4*C*VT);
    c5 = I0/(12*C*gamma);
    
    d1 = 1 - x1^2;
    d2 = 1 - x2^2;
    d3 = 1 - x3^2;
    d4 = 1 - x4^2;
    d5 = 1 - x5^2;
    
    t1 = x2 - v_tilde - x4;
    t2 = x3 - 2*x2 + x1;
    t3 = -x5 - 2*x3 - x2;
    t4 = -x5 - x3;
    t5 = -x5 - x3;
    
    denom = (1 - v_tilde*x4)^2;
    if abs(denom) < 1e-12, denom = 1e-12; end
    f_v = (v_tilde^2 - 1) / denom;
    
    J_f = -[ ...
        2*c1*(d1 + t1*x1),   -c1*d1,             0,         c1*d1*f_v,       0; ...
        -c2*d2,              2*c2*(d2 + t2*x2),   -c2*d2,    0,               0; ...
         0,                  -c3*d3,             2*c3*(d3 + t3*x3),  0,         c3*d3; ...
         0,                   0,                  c4*d4,     2*c4*t4*x4,     c4*d4; ...
         0,                   0,                  c5*d5,     0,              c5*(d5+2*t5*x5) ...
    ];
end
